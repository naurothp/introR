---
title: "Einführung in R"
author: "Peter Nauroth"
output:
  ioslides_presentation: default
  beamer_presentation:
    colortheme: whale
    slide_level: 2
  slidy_presentation: default
---

# 1. Was ist R?
  
## Zentrale Strukturen

__R ist eine Programmiersprache__

  * Datenstrukturen & Datentyp
    *	Datentyp (`mode()`): numeric, character, boolean, factor
    * Datenstruktur (`str()`)
    *	*Viele Fehlermeldungen sind darauf zurückzuführen, dass der Datentyp oder die Datenstruktur nicht zur Funktion passen!*
  * Operatoren (z.B. Zuordnung: `x <- 5`)
  * Funktionen (z.B. `'+'(4,5)`)
    * Funktionsparameter

# 2. RStudio

## GUI

__1. Konsole__

  * Taschenrechner (`4+4`)

__2. Skript__

__3. Workspace / History / GIT__

  * *Viele Probleme sind auf unbeabsichtigte Objekte im Workspace zurükzuführen.*
    *  `rm(list=ls())` --> Säubern des Workspace
    * erfordert mehr Mikromanagement als SPSS

## GUI
  
__4. Files / Plots / Packages / Help__

  *	Working Directory beachten (`setwd()`)
  * Hilfe (`?`; z.B. `?lm`)
	* Packages / Libraries
    * Für (fast) alles gibt es bereits vorgefertigte Funktionen in Packeten
    * Um diese nutzen zu können: `install.packages()` & `library()`
    
# 3. Datenstrukturen

## 3.1 Homogene Datenstrukturen

Homogene Datenstrukturen enthalten nur einen Datentyp.

__1. Skalare__
```{r eval=FALSE}
s <- 5
s
str(s)
s + 4
s * 2
```

## 3.1 Homogene Datenstrukturen

__2. Vektoren__
```{r eval=FALSE}
v <- c(5,4,5)
v
str(v)
v + 4
v * 2
# get 3rd element:
v[3]
```

## 3.1 Homogene Datenstrukturen

__3. Matrizen__
```{r eval=FALSE}
m1 <- matrix(c(1,123,4,12,3,5), nrow=2)
m1
str(m1)
m1 + 4
m1 * 2
m2 <- matrix(c("1","123","4","12","3","5"), nrow=2)
m2
str(m2)
# get 2nd element in 1st row:
m2[1,2]
# get 2nd column:
m2[,2]

```

## 3.2 Heterogene Datenstrukturen

Datenstruktur mit potentiell unterschiedlichen Datentypen.

__1. Data frames__
```{r eval=FALSE}
subject <- c(2,3,4)
condition <- as.factor(c("EG","KG","EG"))
dv <-  c(5,5,5)
df <- data.frame(subject, condition, dv)
df
str(df)

# get values of dv:
df$dv
# alternatively
df[,3]
# get values of subject 3:
df[df$subject==3,]
# alternatively
df[2,]
```

## 3.2 Heterogene Datenstrukturen

__1. Data frames__

```{r eval=FALSE}
# get condition & dv
df[,c(2,3)]
```

* Data frames sind die Struktur in der unsere Daten normalerweiser oganisiert sind.

> TODO: Gebe die Bedingungszugehörigkeit von Subjekt 4 auf der Konsole aus.

<!-- df[3,2]-->
<!-- df[df$subject==4,names(df)]-->

## 3.2 Heterogene Datenstrukturen

__2. Listen__
```{r eval=FALSE}
l <- list(c("a", "b", "c"), c(1,2,3,4), 
          c(TRUE, FALSE, TRUE))
l
str(l)

# get 1st value of 3rd object in list
l[[3]][1]

```
* Viele Outputs von statistischen Funktionen sind Listen.

__Das Verständnis über den Zugriff auf und die Organisation von Datenstrukturen ist essentiell für das Arbeiten mit R.__

# 4. Funktionen

## Grundsätzliches

*Funktionen sind Methoden mit denen wir unsere Daten manipulieren und analyiseren.*

Ein Funktion hat (einen):

  * _Namen_ (z. B.: `mean`),
  * _Parameter_ bzw. _Argumente_ (z. B.: `c(1,2,3)`) 
    + notwendige und
    + optionale
  * _Rückgabewert_ (z. B.: `## [1] 2`).

## Grundsätzliches

```{r eval=FALSE}
x <- c(1:10)
x
# Calculate mean of x
mean(x) # That's a function call and x is a function 
        # parameter/argument
# However, mean() may have more parameters. Try:
?mean
```

> TODO: Berechne den Mittelwert von `x <- c(1:78, NA)`.

<!-- mean(x, na.rm=TRUE)-->

## Selbstdefinierte Funktionen

* Funktionen können selbst definiert werden:
```{r eval=FALSE}
# We want a function that squares its input:
y <- 5
y*y
f1 <- function(x) x*x
f1(y)
```

> TODO1: Definiere eine Funktion, die ihren Input verdoppelt und anschließend 5 addiert.



> TODO2: Definiere eine Funktion, die den Mittelwert eines Vektors berechnet und vorher mögliche NAs entfernt (Tipp: `?mean`).

## Selbstdefinierte Funktionen

```{r eval=FALSE}
squarePlusFive <- function(x) 2*x+5
myMean <- function(x) mean(x, na.rm=TRUE)
```

## Funktionen

**Für fast alles gibt es bereits Funktionen.**

  * Bevor man anfängt eine eigene Funktion zu schreiben lohnt sich eine Suche im Internet:
    + [StackOverflow](http://www.stackoverflow.de)
    + [Quick-R](http://www.statmethods.net/)
    + [R-bloggers](http://www.r-bloggers.com/)

# 5. Daten

## Einlesen von .csv Dateien
```{r eval=FALSE}
data <- read.csv(file="data.csv")
# read.table offers most important wrappers for importing 
# .txt or .csv files
?read.table
```

> TODO: Welche Wrapper sind am günstigsten um mit Excel erstellte .csv-Dateien einzulesen? (Tipp: Erstelle eine .csv mit Excel und öffne sie mit einem Texteditor)

## Einlesen von .csv Dateien

* R nutzt "/" oder "\\\\" um Ordner anzusteuern (nicht "\\" wie in Windows üblich):
```{r eval=FALSE}
d <- read.delim2(
      "H:/Arbeit/Studien/3-SR-S0/data/data_SR.csv")
# Or:
d <- read.delim2(
      "H:\\Arbeit\\Studien\\3-SR-S0\\data\\data_SR.csv")
```

## Einlesen von .sav Dateien (SPSS)
* Um SPSS-Files einlesen zu können, brauchen wir ein spezielles Packet

```{r eval=FALSE}
install.packages("foreign") # install foreign package
library(foreign)        # load the foreign package 
?read.spss              # check out the documentation
myData <- read.spss("myfile.sav", to.data.frame=TRUE)
```

> TODO: Einlesen einer eigenen SPSS Datei in R.

<!-- http://www.castonline.ilstu.edu/smith/445/assspss/march%20madness.sav -->

## Daten verstehen

```{r eval=FALSE}
install.packages("ggplot2")
install.packages("psych")
library(ggplot2)
library(psych)

str(diamonds)
head(diamonds)
View(diamonds)
summary(diamonds)

pairs.panels(diamonds)
```

## Manipulation von Daten

  * Häufig müssen wir vorliegende Daten verändern ("manipulieren") um sie auswerten zu können.
  * Beispiel:
    * Wir wollen die Korrelationen von `carat`, `depth` und `price`
    * Hilfreiche Funktion: `cor()`

> TODO: Gebe die Korrelationsmatrix der drei Variablen auf der Konsole aus.

## Manipulation von Daten

```{r eval=FALSE}
cor(diamonds[,c(1,5,7)])
```

  * Ein Problem dabei ist, dass wir immer die Spaltenposition der Variablen wissen müssen.
  * Ein Packet das Datenmanipulationen enorm erleichtert ist `dplyr`.

## `dplyr`

*Eine kurze und gute Einführung in dplyr findet man hier: [Advanced R Programming](http://moc.environmentalinformatics-marburg.de/gitbooks/advancedProgrammingInR/_book/index.html)*

```{r eval=FALSE}
install.packages("dplyr")
library(dplyr)            # Did you get any messages?
```

  * Zentrale Funktionen:
    + tbl_df
    + filter
    + select
    + arrange

## `dplyr::tbl_df`

```{r eval=FALSE}
diamonds
myData <- tbl_df(diamonds)
myData
```

## `dplyr::filter`

Häufig wollen wir nur Untermengen unserer Daten betrachten. Beispielsweise wollen wir uns nur Daten einer Bedingung anschauen.

```{r eval=FALSE}
# get all diamonds with premium cut
myData[myData$cut=="Premium",]
filter(myData, cut %in% c("Premium"))
# not really more efficient
# but what if we want: 
#   all I- or J-colored 
#   with 'Fair' or 'Good' cut quality 
#   and a weight of more than 4 carat?
```

## `dplyr::filter`

```{r eval=FALSE}
myData[myData$cut %in% c("Fair","Good") & 
       myData$color %in% c("I", "J") &
       myData$carat > 4,]

filter(diamonds, carat > 4 &
         cut %in% c("Fair","Good") &
         color %in% c("I", "J"))
```

## `dplyr::select`

Bestimmte Spalten auszuwählen und damit weiterzuarbeiten ist eine der häufigsten Arbeitsschritte in R.

```{r eval=FALSE}
select(myData, carat, cut, color, price)
select(myData, carat:color, price)
```

Mithilfe von `dplyr::select` spart man sich den Zugriff über die Spaltennummern.

## `dplyr::arrange`

Manchmal möchte man einen Datensatz nach bestimmten Kriterien ordnen.

```{r eval=FALSE}
# order the data ascending for carat and with
# diamonds of same carat beeing sortet by descending
# prices
arrange(myData, carat, desc(price))
```

## `dplyr`

  * Sehr nützliches Packet für einfache Datenmanipulationen
  * Andere nützliche Funktionen in `dplyr`
    + `mutate`
    + `summarize`
    + `group by`
   
# EXKURS: Explorative Faktorenanalyse

## Explorative Faktorenanalyse
```{r eval=FALSE}
install.packages("nFactors")
library(nFactors)

# Maximum Likelihood Factor Analysis
# entering raw data and extracting 1 factor, 
# with varimax rotation 
factor.myData <- dplyr::select(myData, carat, price:z)
fit <- factanal(factor.myData, 1, rotation="varimax")
print(fit, digits=2, cutoff=.3, sort=TRUE)
```

## Explorative Faktorenanalyse
```{r eval=FALSE}
# Scree and other test
ev <- eigen(cor(factor.myData)) # get eigenvalues
ap <- parallel(subject=nrow(factor.myData),var=ncol(factor.myData),
  rep=100,cent=.05)
nS <- nScree(x=ev$values, aparallel=ap$eigen$qevpea)
plotnScree(nS)
```
